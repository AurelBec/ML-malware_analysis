///
/// \file Classifiers.hpp
/// \brief Contains the definition of different classifiers
/// \author Aurelien Bec
/// \date November 17th 2017
///

#ifndef CLASSIFIER_HPP
#define CLASSIFIER_HPP

#include "VectorSpace.hpp"

#include <iomanip>

///
/// \class NaiveBayesClassifier
/// \brief Parent Classifier
///
/// This class is used to create a classifier
///
class NaiveBayesClassifier
{
public :
    ///
    /// \brief Constructor
    ///
    /// Constructor of the parent class NaiveBayesClassifier
    ///
    /// \param pDS: RELATIVE path to the directory containing all the examples
    /// \param pHD: RELATIVE path to the SHA1 HASH file, containing name and family of known malware
    /// \param sets: The ids of the sets considered by the classifier
    /// \param percent: Percent of all availbale examples used for training
    ///
    NaiveBayesClassifier(const boost::filesystem::path& pDS, const boost::filesystem::path& pHD, const std::set<int>& sets, const uint percent);

    ///
    /// \brief Destructor
    ///
    /// Vitrual Destructor of the parent class NaiveBayesClassifier
    ///
    virtual ~NaiveBayesClassifier() {for(Class* itClass : m_class) delete itClass;}

    ///
    /// \brief Classify
    ///
    /// Classifies examples in the know and/or unkwon domain
    ///
    /// \param nbTests: number of examples to classify
    ///
    void evaluate(const uint nbTests) const;

protected :
    ///
    /// \brief Train
    ///
    /// Train our classifier with m_sizeTrain examples
    ///
    virtual void train() = 0;

    ///
    /// \brief Evaluate
    ///
    /// Classifies nb examples in the domain selected and show results
    ///
    /// \param nb: Number of examples to classify
    /// \param to: Position of the first file of the domain
    /// \param from: Position of the last file of the domain
    ///
    ///   (0 <= nb <= from - to)
    ///
    virtual void evaluate(const uint nb, const uint to, const uint from) const = 0;

    ///
    /// \brief getClass
    ///
    /// Returns the most likely class of the example
    ///
    /// \param filePath: RELATIVE path to the example
    ///
    /// \return The most likely class
    ///
    virtual const std::string getClass(const boost::filesystem::path& filePath) const;

    const uint m_percent;   ///< Percent of all availbale examples used for training
    uint m_total;           ///< Total of all the examples available
    uint m_sizeTrain;       ///< Maximum number of examples to train our classifier (= total * percent)
    uint m_sizeTest;        ///< Maximum number of examples to test our classifier (= total - train)

    const boost::filesystem::path m_pathHashDico;   ///< RELATIVE path to the SHA1 HASH file, containing name and family of known malware
    const boost::filesystem::path m_pathDataSet;    ///< RELATIVE path to the directory containing all the examples
    std::set<std::string> m_hashMalware;            ///< All the name of known malware (read from m_pathHashDico)
    std::vector<Class*> m_class;                    ///< Contains each class the classifier study
    const std::set<int> m_sets;                     ///< Contains the id of the SubSets considered by the classifier
};

///
/// \class FamilyClassifier
/// \brief Malware family classifier (inherited from NaiveBayesClassifier )
///
/// This class is used to create a malware family classifier
///
class FamilyClassifier : public NaiveBayesClassifier
{
public:
    ///
    /// \brief Constructor
    ///
    /// Constructor of the inherited class FamilyClassifier
    ///
    /// \param pDS: RELATIVE path to the directory containing all the examples
    /// \param pHD: RELATIVE path to the SHA1 HASH file, containing name and family of known malware
    /// \param sets: The ids of the sets considered by the classifier
    /// \param percent: Percent of all availbale examples used for training
    ///
    FamilyClassifier(const boost::filesystem::path& pDS, const boost::filesystem::path& pHD, const std::set<int>& sets, const uint percent);

    ///
    /// \brief Destructor
    ///
    /// Destructor of the inherited class FamilyClassifier
    ///
    ~FamilyClassifier() {};

    using NaiveBayesClassifier::evaluate;

private :
    ///
    /// \brief Train
    ///
    /// Train our classifier with m_sizeTrain examples
    ///
    void train();

    ///
    /// \brief Evaluate
    ///
    /// Classifies nb examples in the domain selected and show results
    ///
    /// \param nb: Number of examples to classify
    /// \param to: Position of the first file of the domain
    /// \param from: Position of the last file of the domain
    ///
    ///   (0 <= nb <= from - to)
    ///
    void evaluate(const uint nb, const uint to, const uint from) const;
};

///
/// \class MalwareDetector
/// \brief Malware detector (inherited from NaiveBayesClassifier )
///
/// This class is used to create a malware detector
///
class MalwareDetector : public NaiveBayesClassifier
{
public:
    ///
    /// \brief Constructor
    ///
    /// Constructor of the inherited class MalwareClassifier
    ///
    /// \param pDS: RELATIVE path to the directory containing all the examples
    /// \param pHD: RELATIVE path to the SHA1 HASH file, containing name and family of known malware
    /// \param sets: The ids of the SubSets considered by the classifier
    /// \param percent: Percent of all availbale examples used for training
    ///
    MalwareDetector(const boost::filesystem::path& pDS, const boost::filesystem::path& pHD, const std::set<int>& sets, const uint percent);

    ///
    /// \brief Destructor
    ///
    /// Destructor of the inherited class MalwareClassifier
    ///
    ~MalwareDetector() {};

    using NaiveBayesClassifier::evaluate;

private :
    ///
    /// \brief Train
    ///
    /// Train our classifier with m_sizeTrain examples
    ///
    void train();

    ///
    /// \brief Evaluate
    ///
    /// Classifies nb examples in the domain selected and show results
    ///
    /// \param nb: Number of examples to classify
    /// \param to: Position of the first file of the domain
    /// \param from: Position of the last file of the domain
    ///
    ///   (0 <= nb <= from - to)
    ///
    void evaluate(const uint nb, const uint to, const uint from) const;
};

#endif
