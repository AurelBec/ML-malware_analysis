///
/// \file VectorSpace.hpp
/// \brief Contains the definition of VectorSpace and the other class need
/// \author Aurelien Bec
/// \date November 17th 2017
///

#ifndef VECTOR_HPP
#define VECTOR_HPP

#include "define.hpp"

#include <set>
#include <cmath>
#include <vector>
#include <fstream>
#include <boost/filesystem.hpp>
#include <boost/lambda/bind.hpp>
#include <boost/algorithm/string.hpp>

///
/// \class Value
/// \brief class Value
///
/// This class is used to represents the node of a graph
///
class Value
{
public:
    ///
    /// \brief Constructor
    ///
    /// Default constructor of the class Value
    ///
    Value() : m_occ(0), m_value("~") {};

    ///
    /// \brief Constructor
    ///
    /// Constructor of the class Value
    ///
    /// \param value: value contained by the node
    ///
    Value(const std::string& value) : m_occ(0), m_value(value) {};

    ///
    /// \brief Destructor
    ///
    /// Destructor of the class Value
    /// Delete recursively all the Value of the SubSet
    ///
    ~Value() { for(Value* next : m_next) delete next;}

    ///
    /// \brief Add occurence
    ///
    /// Adds one to the number of value's occurence
    ///
    inline void addOcc() {m_occ ++;};

    ///
    /// \brief Get occurence
    ///
    /// Returns the number of times the value appear in the SubSet
    ///
    /// \return true if added, false if not
    ///
    inline const uint getOcc() const {return m_occ;};

    ///
    /// \brief Add a value to the graph
    ///
    /// Adds a new value to the successors of the current node
    ///
    /// \param value: The value to add
    ///
    inline void addNext(const std::string& value) {m_next.push_back(new Value(value));};

    ///
    /// \brief Go to next
    ///
    /// Returns the adress of the next Value containing value
    ///
    /// \param value: The value to look for in the nexts
    ///
    /// \return Adress of the next Value, NULL if it doesn't exist
    ///
    inline Value* goNext(const std::string& value);

    ///
    /// \brief Get value
    ///
    /// Returns the value of the current node
    ///
    /// \return value
    ///
    inline const std::string& getValue() const {return m_value;};

    ///
    /// \brief Check if the value exists in the successors
    ///
    /// Checks if a value is in the successors of the current node
    ///
    /// \param value: The value to check
    ///
    /// \return true if yes, false if not
    ///
    inline const bool isInNext(const std::string& value) const;

    ///
    /// \brief Operator <<
    ///
    /// Overloads the << operator to print a Value
    ///
    friend std::ostream& operator<<(std::ostream& out, const Value& v);

private:
    ///
    /// \brief Print the value
    ///
    /// Prints recursively the value and all the nexts
    ///
    void print(std::ostream& out, const std::string offset) const;

    uint m_occ;                 ///< Number of times the value appear in the SubSet
    const std::string m_value;  ///< String stored in the Value
    std::vector<Value*> m_next; ///< Adresses of all the following Values
};

///
/// \class SubSet
/// \brief class SubSet
///
/// This class represents a set
/// Contains the id of the set and a graph with all the value read in the examples which belong to this set
///
class SubSet
{
public:
    ///
    /// \brief Constructor
    ///
    /// Only constructor of the class SubSet
    ///
    SubSet(const int id) : m_id(id), m_nbValue(0) {};

    ///
    /// \brief Destructor
    ///
    /// Destructor of the class SubSet
    ///
    ~SubSet(){};

    ///
    /// \brief Add a value to the graph
    ///
    /// Adds a new value to the graph which start at m_root
    ///
    /// \param value: The value to add
    ///
    void add(const std::string& value);

    ///
    /// \brief Get id
    ///
    /// Returns the id of the SubSet
    ///
    /// \return The id of the SubSet
    ///
    inline const int getId() const {return m_id;};

    ///
    /// \brief Get name
    ///
    /// Returns the name of the SubSet
    ///
    /// \return The name of the SubSet
    ///
    inline const std::string& name() const {return setNames[m_id];};

    ///
    /// \brief Get name
    ///
    /// Returns the name of a SubSet
    ///
    /// \param id: The set's id to return the name
    ///
    /// \return The name of a SubSet
    ///
    static inline const std::string& name(const uint id) {return setNames[id];};

    ///
    /// \brief Get occurence
    ///
    /// Returns the occurence of specified value in the SubSet
    ///
    /// \param value: The value to return the occurence
    ///
    /// \return The occrence of the value
    ///
    const uint getOcc(const std::string& value);

    ///
    /// \brief Get id
    ///
    /// Returns the sum of occurence of all the values in the SubSet
    ///
    /// \return The sum of occurence
    ///
    inline const uint getOcc() const {return m_nbValue;};

    ///
    /// \brief Get natural logarithmic probability
    ///
    /// Returns the natural logarithmic propobability of occurence of a value in the SubSet
    ///
    /// \param value: The value to check the probability
    ///
    /// \return The natural logarithmic propobability of occurence of a value
    ///
    inline const long double getLogProbability(const std::string& value);

    ///
    /// \brief Operator <<
    ///
    /// Overloads the << operator to print a Value
    ///
    friend std::ostream& operator<<(std::ostream& out, const SubSet& ss);


private:
    static const std::vector<std::string> setNames; ///< Stored the name of an id corresponding to a SubSet
    const int m_id;                                 ///< Id of the SubSet
    uint m_nbValue;                                 ///< Number of values in the SubSet
    long double m_nbLValue;                         ///< Natural logarithmic number of value
    Value m_root;                                   ///< First node of the graph of Values
};

///
/// \class Class
/// \brief Parent Classifier
///
/// This class is used to create a classifier
///
class Class
{
public :
    ///
    /// \brief Constructor
    ///
    /// Constructor of the class Class
    ///
    /// \param name: The name of the Class
    ///
    Class(const std::string& name): m_nbMan(0), m_nbValue(0), m_name(name) { for (uint i(0); i < 8; ++i) m_sets.push_back(new SubSet(i));}

    ///
    /// \brief Constructor
    ///
    /// Only constructor of the class SubSet
    ///
    /// \param name: The name of the Class
    /// \param sets: The ids of the SubSet the Class have to considered
    ///
    Class(const std::string& name, const std::set<int>& sets): m_nbMan(0), m_nbValue(0), m_name(name) { for(int id : sets) m_sets.push_back(new SubSet(id-1));}

    ///
    /// \brief Destructor
    ///
    /// Destructor of the class Class
    ///
    ~Class() { for(SubSet* set : m_sets) delete set;};

    ///
    /// \brief Study a manifest
    ///
    /// Learns data from a manifest during the training phase
    ///
    /// \param filePath: The path to the manifest
    ///
    void study(const boost::filesystem::path& filePath);

    ///
    /// \brief Get the name of the Class
    ///
    /// Returns the name of the Class
    ///
    /// \return The name of the Class
    ///
    inline const std::string& name() const {return m_name;};

    ///
    /// \brief Get the size of the Class
    ///
    /// Returns the size of the Class, the number of manifest studied
    ///
    /// \return The size of the Class
    ///
    // inline const uint size() const {return m_size;};
    inline const uint nbManifests() const {return m_nbMan;};

    ///
    /// \brief Set the number of value in the Class
    ///
    /// Sets the number of value studied in the Class
    ///
    inline void setNbValue() {for(SubSet* set : m_sets) m_nbValue += set->getOcc();};

    ///
    /// \brief Set the probability of occurence of the Class
    ///
    /// Sets the probability of the occurence of the Class
    ///
    inline void setProbability(const uint total) { m_pL = log(static_cast<long double>(m_nbMan)) - log(static_cast<long double>(total));}

    ///
    /// \brief Get the natural logarithmic probability of occurence of a value
    ///
    /// Gets the probability of occurence of a value in the Class
    ///
    /// \param prefix: The set in which look for the value
    /// \param value: The value to look for
    ///
    /// \return The natural logarithmic probability of occurence of a value
    ///
    const long double getLogProbability(const std::string& prefix, const std::string& value) const;

    ///
    /// \brief Get the probability of occurence of the Class
    ///
    /// Returns the probability of occurence of the Class
    ///
    /// \return The probability of occurence of the Class
    ///
    inline const long double getLogProbability() const { return m_pL;};

    friend std::ostream& operator<<(std::ostream& out, const Class& c);

private :
    ///
    /// \brief Get the id of a SubSet
    ///
    /// Returns the id of a SubSet
    ///
    /// \param prefix: The name of the SubSet to look for
    ///
    /// \return The id of the SubSet
    ///
    const int getSetId(const std::string& prefix) const;

    uint m_nbMan;                   ///< Number of manifests studied during training phase
    uint m_nbValue;                 ///< Number of value studied during training phase
    long double m_pL;               ///< Natural logarithmic probability of Class' occurence
    std::vector<SubSet*> m_sets;    ///< Sets considered by the classifer
    const std::string m_name;       ///< Name of the Class
};

#endif