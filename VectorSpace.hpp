#ifndef VECTOR_HPP
#define VECTOR_HPP

///
/// \file VectorSpace.hpp
/// \brief Contains the definition of VectorSpace and the other class need
/// \author Aurelien Bec
/// \date November 17th 2017
///

#include "define.hpp"

#include <set>
#include <cmath>
#include <vector>
#include <fstream>
#include <iostream>
#include <boost/filesystem.hpp>
#include <boost/lambda/bind.hpp>
#include <boost/algorithm/string.hpp>

///
/// \class Value
/// \brief class Value
///
/// This class is used to represents the node of a graph
///
class Value
{
public:
    ///
    /// \brief Constructor
    ///
    /// Default constructor of the class Value
    ///
    Value() : m_occ(0), m_value("~") {};

    ///
    /// \brief Constructor
    ///
    /// Constructor of the class Value
    ///
    /// \param value: value contained by the node
    ///
    Value(const std::string& value) : m_occ(0), m_value(value) {};

    ///
    /// \brief Destructor
    ///
    /// Destructor of the class Value
    /// Delete recursively all the Value of the SubSet
    ///
    ~Value() { for(Value* next : m_next) delete next;}

    ///
    /// \brief Add occurence
    ///
    /// Adds one to the number of value's occurence
    ///
    void addOcc() {m_occ ++;};

    ///
    /// \brief Get occurence
    ///
    /// Returns the number of times the value appear in the SubSet
    ///
    /// \return true if added, false if not
    ///
    const uint getOcc() const {return m_occ;};

    ///
    /// \brief Add a value to the graph
    ///
    /// Adds a new value to the successors of the current node
    ///
    /// \param value: The value to add
    ///
    void addNext(const std::string& value) {m_next.push_back(new Value(value));};

    ///
    /// \brief Go to next
    ///
    /// Returns the adress of the next Value containing value
    ///
    /// \param value: The value to look for in the nexts
    ///
    /// \return Adress of the next Value, NULL if it doesn't exist
    ///
    Value* goNext(const std::string& value);

    ///
    /// \brief Get value
    ///
    /// Returns the value of the current node
    ///
    /// \return value
    ///
    const std::string& getValue() const {return m_value;};

    ///
    /// \brief Check if the value exists in the successors
    ///
    /// Checks if a value is in the successors of the current node
    ///
    /// \param value: The value to check
    ///
    /// \return true if yes, false if not
    ///
    const bool isInNext(const std::string& value) const;

    ///
    /// \brief Operator <<
    ///
    /// Overloads the << operator to print a Value
    ///
    friend std::ostream& operator<<(std::ostream& out, const Value& v);

private:
    ///
    /// \brief Print the value
    ///
    /// Prints recursively the value and all the nexts
    ///
    void print(std::ostream& out, const std::string offset) const;

    uint m_occ;                 ///< Number of times the value appear in the SubSet
    const std::string m_value;  ///< String stored in the Value
    std::vector<Value*> m_next; ///< Adresses of all the following Values
};

///
/// \class SubSet
/// \brief class SubSet
///
/// This class represents a set
/// Contains the id of the set and a graph with all the value read in the examples which belong to this set
///
class SubSet
{
public:
    ///
    /// \brief Constructor
    ///
    /// Only constructor of the class SubSet
    ///
    SubSet(const int id) : m_id(id), m_nbValue(0) {};

    ///
    /// \brief Destructor
    ///
    /// Destructor of the class SubSet
    ///
    ~SubSet(){};

    ///
    /// \brief Add a value to the graph
    ///
    /// Adds a new value to the graph which start at m_root
    ///
    /// \param value: The value to add
    ///
    void add(const std::string& value);

    ///
    /// \brief Get id
    ///
    /// Returns the id of the SubSet
    ///
    /// \return The id of the SubSet
    ///
    const int getId() const {return m_id;};

    ///
    /// \brief Get name
    ///
    /// Returns the name of the SubSet
    ///
    /// \return The name of the SubSet
    ///
    const std::string& name() const {return setNames[m_id];};

    ///
    /// \brief Get name
    ///
    /// Returns the name of a SubSet
    ///
    /// \param id: The set's id to return the name
    ///
    /// \return The name of a SubSet
    ///
    static const std::string& name(const uint id) {return setNames[id];};

    ///
    /// \brief Get occurence
    ///
    /// Returns the occurence of specified value in the SubSet
    ///
    /// \param value: The value to return the occurence
    ///
    /// \return The occrence of the value
    ///
    const uint getOcc(const std::string& value);

    ///
    /// \brief Get natural logarithmic probability
    ///
    /// Returns the natural logarithmic propobability of occurence of a value in the SubSet
    ///
    /// \param value: The value to check the probability
    ///
    /// \return The natural logarithmic propobability of occurence of a value
    ///
    const long double getLogProbability(const std::string& value);

    ///
    /// \brief Operator <<
    ///
    /// Overloads the << operator to print a Value
    ///
    friend std::ostream& operator<<(std::ostream& out, const SubSet& ss);


private:
    static const std::vector<std::string> setNames; ///< Stored the name of an id corresponding to a SubSet
    const int m_id;                                 ///< Id of the SubSet
    uint m_nbValue;                                 ///< Number of values in the SubSet
    long double m_nbLValue;                         ///< Natural logarithmic number of value
    Value m_root;                                   ///< First node of the graph of Values
};

///
/// \class Class
/// \brief Parent Classifier
///
/// This class is used to create a classifier
///
class Class
{
public :
    Class(const std::string& name): m_size(0), m_name(name) { for (uint i(0); i < 8; ++i) m_sets.push_back(new SubSet(i));}
    Class(const std::string& name, const std::set<int>& sets): m_size(0), m_name(name) { for(int id : sets) m_sets.push_back(new SubSet(id-1));}
    ~Class() { for(SubSet* set : m_sets) delete set;};

    void study(const boost::filesystem::path& filePath);
    const std::string& name() const {return m_name;};
    const uint size() const {return m_size;};
    const SubSet* getSet(const uint id) const {return m_sets[id];};
    const std::vector<SubSet*>& getSet() const {return m_sets;};

    void setProbability(const uint total) { m_pL = log(static_cast<long double>(m_size)) - log(static_cast<long double>(total));}
    const long double getLogProbability(const std::string& prefix, const std::string& value) const;
    const long double getProbability() const { return exp(m_pL);};
    const long double getLogProbability() const { return m_pL;};

    friend std::ostream& operator<<(std::ostream& out, const Class& c);

private :
    const int getSetId(const std::string& prefix) const;

    uint m_size;
    long double m_pL;
    std::vector<SubSet*> m_sets;
    const std::string m_name;
};

#endif