#ifndef VECTOR_HPP
#define VECTOR_HPP

///
/// \file VectorSpace.hpp
/// \brief Contains the definition of VectorSpace and the other class need
/// \author Aurelien Bec
/// \date November 17th 2017
///

#include "define.hpp"

#include <set>
#include <cmath>
#include <vector>
#include <fstream>
#include <iostream>
#include <boost/filesystem.hpp>
#include <boost/lambda/bind.hpp>
#include <boost/algorithm/string.hpp>



///
/// \class Value
/// \brief class Value
///
/// This class is used to represents the node of a graph
///
class Value
{
public:
	///
	/// \brief Constructor
	///
	/// Default constructor of the class Value
	///
	Value() : m_occ(0), m_value("~") {};

	///
	/// \brief Constructor
	///
	/// Constructor of the class Value
	///
	/// \param value: value contained by the node
	///
	Value(const std::string& value) : m_occ(0), m_value(value) {};

	///
	/// \brief Destructor
	///
	/// Destructor of the class Value
	/// Delete recursively all the Value of the SubSet
	///
	~Value() { for(Value* next : m_next) delete next;}

	///
	/// \brief Add occurence
	///
	/// Add one to the number of value's occurence
	///
	void addOcc() {m_occ ++;};

	///
	/// \brief Add a value to the graph
	///
	/// Adde a new value to the successors of the current node
	///
	/// \param value: The value to add
	///
	/// \return true if added, false if not
	///
	void addToNext(const std::string& value) {m_next.push_back(new Value(value));};

	///
	/// \brief Get occurence
	///
	/// Returns the number of times the value appear in the SubSet
	///
	/// \return true if added, false if not
	///
	const uint getOcc() const {return m_occ;};

	///
	/// \brief Check if the value exists in the successors
	///
	/// Checks if a value is in the successors of the current node
	///
	/// \param value: The value to check
	///
	/// \return true if yes, false if not
	///
	const bool isInNext(const std::string& value) const;

	///
	/// \brief Get value
	///
	/// Returns the value of the current node
	///
	/// \return value
	///
	const std::string& getValue() const {return m_value;};


	Value* goTo(const std::string& value);

    friend std::ostream& operator<<(std::ostream& out, const Value& v);

private:
	void print(std::ostream& out, const std::string offset) const;

	uint m_occ;
	const std::string m_value;
	std::vector<Value*> m_next;
};

///
/// \class SubSet
/// \brief class SubSet
///
/// This class represents a set
/// Contains the id of the set and a graph with all the value read in the examples which belong to this set
///
class SubSet
{
public:
	SubSet(const int id) : m_id(id) {};
	~SubSet(){};

	void add(const std::string&  value);
	const int getId() const {return m_id;};
	const std::string& getName() const {return setNames[m_id];};
	const uint getOcc(const std::string& value);
	const long double getLogProbability(const std::string& value);

	static const std::vector<std::string> setNames;
    friend std::ostream& operator<<(std::ostream& out, const SubSet& s);

private:
	uint m_nbValue;
	long double m_nbLValue;
	const int m_id;
	Value m_root;
};

///
/// \class Class
/// \brief Parent Classifier
///
/// This class is used to create a classifier
///
class Class
{
public :
	Class(const std::string& name): m_size(0), m_name(name)	{ for (uint i(0); i < 8; ++i) m_sets.push_back(new SubSet(i));}
	Class(const std::string& name, const std::set<int>& sets): m_size(0), m_name(name) { for(int id : sets) m_sets.push_back(new SubSet(id-1));}
	~Class() { for(SubSet* set : m_sets) delete set;};

	void study(const boost::filesystem::path& filePath);
	const std::string& name() const {return m_name;};
	const uint size() const {return m_size;};
	const SubSet* getSet(const uint id) const {return m_sets[id];};
	const std::vector<SubSet*>& getSet() const {return m_sets;};

	void setProbability(const uint total) { m_pL = log(static_cast<long double>(m_size)) - log(static_cast<long double>(total));}
	const long double getLogProbability(const std::string& prefix, const std::string& value) const;
	const long double getProbability() const { return exp(m_pL);};
	const long double getLogProbability() const { return m_pL;};

    friend std::ostream& operator<<(std::ostream& out, const Class& vs);

private :
	const int getSetId(const std::string& prefix) const;

	uint m_size;
	long double m_pL;
	std::vector<SubSet*> m_sets;
	const std::string m_name;
};

#endif