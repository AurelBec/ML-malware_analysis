#include "Classifiers.hpp"

using namespace std;
using namespace boost;
using namespace boost::lambda;
using namespace boost::filesystem;


/////////////////////////////////////////
///
/// NAIVE BAYES CLASSIFIER method's definitions
///
////////////////////////////////////////


NaiveBayesClassifier::NaiveBayesClassifier(const path& pDS, const path& pHD, const set<int>& sets, const uint percent)
: m_percent(percent)
, m_pathHashDico(pHD)
, m_pathDataSet(pDS)
, m_sets(sets)
{
	string line;
	vector<string> info;
	ifstream hashDico(m_pathHashDico.string());

	getline(hashDico, line);
	while(getline(hashDico, line))
	{
		split(info, line, is_any_of(",\r"));
		m_hashMalware.insert(info.front());
	}
	hashDico.close();

	if(DEBUG_ON) cout << "D: " << m_hashMalware.size() << " known malwares" << endl;
}

void NaiveBayesClassifier::evaluate(const uint nbTests) const
{
	cout << endl << "Starting evaluation:";

	cout << endl;
	if( nbTests > m_sizeTrain) cout << "  Warning: Not enough known APKs, will use " << m_sizeTrain << " instead of " << nbTests << endl;
	cout << "  With " << min(nbTests, m_sizeTrain) << " known APKs:" << endl;
	evaluate(min(nbTests, m_sizeTrain), 0, m_sizeTrain);

	cout << endl;
	if( nbTests > m_sizeTest) cout << "  Warning: Not enough unknown APKs, will use " << m_sizeTest << " instead of " << nbTests << endl;
	cout << "  With " << min(nbTests, m_sizeTest) << " unknown APKs:" << endl;
	evaluate(min(nbTests, m_sizeTest), m_sizeTrain, m_total);

	cout << endl;
	if( nbTests > m_total) cout << "  Warning: Not enough unknown APKs, will use " << m_total << " instead of " << nbTests << endl;
	cout << "  With " << min(nbTests, m_total) << " both known and unknown APKs:" << endl;
	evaluate(min(nbTests, m_total), 0, m_total);
}

const string NaiveBayesClassifier::getClass(const path& filePath) const
{
	int posTok;
	string feature, prefix, value;
	ifstream file(filePath.string());

	vector<long double> pC;
	for(uint i(0); i < m_class.size(); ++i)
		pC.push_back(m_class.at(i)->getLogProbability());

	while(getline(file, feature))
	{
		if((posTok = feature.find("::")) == -1)
			continue;

		prefix = feature.substr(0, posTok);
		value  = feature.substr(posTok + 2);

		for(uint i(0); i < m_class.size(); ++i)
			pC.at(i) += m_class[i]->getLogProbability(prefix, value);
	}
	file.close();

	uint id(0);
	for(uint i(1); i < m_class.size(); ++i)
		if(pC.at(i) >= pC.at(id))
			id = i;

	return m_class[id]->name();
}


/////////////////////////////////////////
///
/// MALWARE DETECTOR method's definitions
///
////////////////////////////////////////


MalwareDetector::MalwareDetector(const path& pDS, const path& pHD, const set<int>& sets, const uint percent)
: NaiveBayesClassifier(pDS, pHD, sets, percent)
{
	m_total = count_if( directory_iterator(pDS), directory_iterator(), static_cast<bool(*)(const path&)>(is_regular_file)); //count the total number of file in the directory
	m_sizeTrain = (m_total * percent) / 100;
	m_sizeTest = m_total - m_sizeTrain;

	if(DEBUG_ON) cout << "D: " << m_total << " manifests in the directory" << endl;

	string nameMalware("Malware"), nameBenign("Benign");
	m_class.push_back(new Class(nameMalware, m_sets));
	m_class.push_back(new Class(nameBenign, m_sets));

	train();
}


void MalwareDetector::train()
{
	cout << endl;

	clock_t begin(clock());
	directory_iterator dir_itr(m_pathDataSet);

	for(uint i(0), percent(100); i < m_sizeTrain; ++i, ++dir_itr)
	{
		if(percent != 100 * (i+1) / m_sizeTrain)
		{
			percent = 100 * (i+1) / m_sizeTrain;
			cout << "\rTraining classifier with "<< m_percent << "% of the set (" << m_sizeTrain << " manifests): " << setw(3) << setfill(' ') << percent << "%" << flush;
		}

		if (is_regular_file(dir_itr->status()))
		{
			if(m_hashMalware.find(dir_itr->path().filename().string()) != m_hashMalware.end())
				m_class[0]->study(dir_itr->path());
			else
				m_class[1]->study(dir_itr->path());
		}
	}

	for(Class* itClass : m_class)
		itClass->setProbability(m_sizeTrain);

	cout << " (" << (clock() - begin) / CLOCKS_PER_SEC << "s)" << endl;
	cout << setw(6) << setfill(' ') << m_class[0]->size() << " malicious APK" << ((m_class[0]->size() > 1) ? "s": "") << " studied" << endl;
	cout << setw(6) << setfill(' ') << m_class[1]->size() << " benign APK" << ((m_class[1]->size() > 1) ? "s": "") << " studied" << endl;

	if(DEBUG_ON)
	{
		cout << endl;
		for(Class* itClass : m_class)
			cout << "D: P(" << itClass->name() << ")= " << itClass->getProbability() << endl;
	}
}

void MalwareDetector::evaluate(const uint n, const uint from, const uint to) const
{
	uint TP(0), FP(0), TN(0), FN(0);
	double precision, recall, falsePositiveRate, accuracy, fMeasure;
	directory_iterator dir_itr(m_pathDataSet);

	for(uint i(0); i < from; ++i)
		dir_itr ++;

	for(uint i(0), percent(100), id(0); i < n; ++i)
	{
		if(percent != 100 * (i+1) / n)
		{
			percent = 100 * (i+1) / n;
			cout << "\r  " << setw(3) << setfill(' ') << percent << "% tested" << flush;
		}

		for(uint j(0); j < rand()%(to - from - n - id + 1) ; ++j) //random choice of the next apk
		{
			id ++;
			dir_itr ++;
		}

		if (is_regular_file( dir_itr->status()))
		{
			if(m_hashMalware.find(dir_itr->path().filename().string()) != m_hashMalware.end()) //malware
				if(getClass(dir_itr->path()) == m_class[0]->name()) TP ++;
			else FN ++;
			else
				if(getClass(dir_itr->path()) == m_class[0]->name()) FP ++;
			else TN ++;
		}

		id --;
	}
	cout << "\r" << flush;

	recall = divide(TP, TP + FN);
	precision = divide(TP, TP + FP);
	falsePositiveRate = divide(FP, FP + TN);
	fMeasure = divide(2 * TP, 2 * TP + FP + FN);
	accuracy = divide(TP + TN, TP + FN + TN + FP);

	if(DEBUG_ON) cout << "D: TP=" << TP << " FN=" << FN << " TN=" << TN << " FP=" << FP << endl;
	cout << "    Precision: " << colorizedValue(precision * 100, false) << endl;
	cout << "    Recall: " << colorizedValue(recall * 100, false) << endl;
	cout << "    False Positive Rate: " << colorizedValue(falsePositiveRate * 100, true) << endl;
	cout << "    Accuracy: " << colorizedValue(accuracy * 100, false) << endl;
	cout << "    F-measure: " << colorizedValue(fMeasure * 100, false) << endl;
}


/////////////////////////////////////////
///
/// FAMILIY CLASSIFIER method's definitions
///
////////////////////////////////////////


FamilyClassifier::FamilyClassifier(const path& pDS, const path& pHD, const set<int>& sets, const uint percent)
: NaiveBayesClassifier(pDS, pHD, sets, percent)
{
	m_total = m_hashMalware.size();
	m_sizeTrain = (m_total * percent) / 100;
	m_sizeTest = m_total - m_sizeTrain;

	train();
}

void FamilyClassifier::train()
{
	cout << endl;

	clock_t begin(clock());

	string line;
	vector<string> info;
	ifstream hashDico(m_pathHashDico.string());
	getline(hashDico, line);

	for(uint i(0), percent(100); i < m_sizeTrain; ++i)
	{
		if(percent != 100 * (i+1) / m_sizeTrain)
		{
			percent = 100 * (i+1) / m_sizeTrain;
			cout << "\rTraining classifier with "<< m_percent << "% of the set (" << m_sizeTrain << " malwares): " << setw(3) << setfill(' ') << percent << "%" << flush;
		}

		getline(hashDico, line);
		line.pop_back(); // delete the '\r\n' char at the end of the line
		split(info, line, is_any_of(","));

		bool isFamilyPresent(false);
		for(Class *itClass : m_class)
		{
			if(itClass->name() == info.back())
			{
				path pathFile(m_pathDataSet.string() + string("/") + info.front());
				itClass->study(pathFile);
				isFamilyPresent = true;
			}
		}

		if(!isFamilyPresent)
		{
			m_class.push_back(new Class(info.back()));
			path pathFile(m_pathDataSet.string() + string("/") + info.front());
			m_class.back()->study(pathFile);
		}
	}
	hashDico.close();

	for(uint i(0); i < m_class.size(); ++i)
	{
		if(m_class[i]->size() < DEFAULT_MINNUMBERSAMPLE)
		{
			delete m_class[i];
			m_class.erase(m_class.begin() + i);
			-- i;
		}
	}

	for(Class* itClass : m_class)
		itClass->setProbability(m_sizeTrain);

	cout << " (" << (clock() - begin) / CLOCKS_PER_SEC << "s)"  << endl;
	cout << setw(5) << setfill(' ') << m_class.size() << " malware families considered (n > " << DEFAULT_MINNUMBERSAMPLE << ")" << endl;

	if(DEBUG_ON)
	{
		cout << endl;
		for(Class* itClass : m_class)
			cout << "D: P(" << itClass->name() << ")= " << itClass->getProbability() << endl;
	}
}


void FamilyClassifier::evaluate(const uint n, const uint from, const uint to) const
{
	long double P(0.0), N(0.0);

	string line;
	vector<string> info;
	ifstream hashDico(m_pathHashDico.string());

	for(uint i(0); i < from + 1; ++i)
		getline(hashDico, line);

	for(uint i(0), id(0), percent(100); i < n; ++i, --id)
	{
		if(percent != 100 * (i+1) / n)
		{
			percent = 100 * (i+1) / n;
			cout << "\r  " << setw(3) << setfill(' ') << percent << "% tested" << flush;
		}

		for(uint j = 0; j < rand()%(to - from - n - id + 1) ; ++j, ++id) //random choice of the next apk
			getline(hashDico, line);

		line.pop_back();
		split(info, line, is_any_of(","));

		for(Class* itClass : m_class)
		{
			if(itClass->name() == info.back())
			{
				if(getClass(path(m_pathDataSet.string() + string("/") + info.front())) == info.back())
					P++;
				else
					N++;
			}
		}
	}

	cout << "\r    Accuracy: " << colorizedValue(divide(P, N + P) * 100, false) << endl << flush;
}