#include "VectorSpace.hpp"

using namespace std;
using namespace boost;
using namespace boost::lambda;
using namespace boost::filesystem;

const vector<string> SubSet::setNames =
    {"Hardware components",     // S1
     "Requested permissions",   // S2
     "App components",          // S3
     "Filtered intents",        // S4
     "Restricted API calls",    // S5
     "Used permissions",        // S6
     "Suspicious API calls",    // S7
     "Network addresses"};      // S8


/////////////////////////////////////////
///
/// CLASS method's definitions
///
////////////////////////////////////////


void Class::study(const path& filePath)
{
    string feature, prefix, value;
    int posTok, idSet;

    ifstream file(filePath.string());

    while(getline(file, feature))
    {

        if((posTok = feature.find("::")) == -1)
            continue;

        prefix = feature.substr(0, posTok);
        value  = feature.substr(posTok + 2);

        if((idSet = getSetId(prefix)) != -1)
        {
            for(SubSet* set : m_sets)
                if(set->getId() == idSet)
                    set->add(value);
        }
    }

    file.close();
    m_size++;
}

const long double Class::getLogProbability(const string& prefix, const string& value) const
{
    int idSet(getSetId(prefix));

    for(SubSet* set : m_sets)
        if(set->getId() == idSet)
                return log(static_cast<long double>(set->getOcc(value))) - log(static_cast<long  double>(m_size));

    return 0.0;
}

const int Class::getSetId(const string& prefix) const
{
    //Ordered by descending direction appartion's times, to optimize the search
    switch(prefix.front())
    {
        case 'u': // url
            return 7;
        case 'p': // permission OR provider
            return (prefix.at(1) == 'e') ? 1 : 2;
        case 's': // service_receiver and service
            return 2;
        case 'a': // activity OR api_call
            return (prefix.at(1) == 'c') ? 2 : 4;
        case 'r': // real_permissions
            return 5;
        case 'c': // call
            return 6;
        case 'i': // intent
            return 3;
        case 'f': // feature
            return 0;
    }

    return -1;
}


/////////////////////////////////////////
///
/// VALUE method's definitions
///
////////////////////////////////////////


const bool Value::isInNext(const string& value) const
{
    for(Value* next : m_next)
        if(next->getValue() == value) return true;

    return false;
}

Value* Value::goNext(const string& value)
{
    for (Value* next : m_next)
        if(next->getValue() == value) return next;

    return NULL;
}


/////////////////////////////////////////
///
/// SUBSET method's definitions
///
////////////////////////////////////////


void SubSet::add(const string&  value)
{
    vector<string> tokValue;
    split(tokValue, toLower(value), is_any_of(TOKENIZERS));

    Value *pos = &m_root;

    for(string tok : tokValue)
    {
        if(tok.size() < 1)
            continue;

        if(!pos->isInNext(tok))
            pos->addNext(tok);
        pos = pos->goNext(tok);
        pos->addOcc();
    }

    if(!pos->isInNext(stringNULL))
        pos->addNext(stringNULL);
    pos = pos->goNext(stringNULL);
    pos->addOcc();

    m_nbValue ++;
    m_nbLValue = log(static_cast<long double>(m_nbValue));
}

const uint SubSet::getOcc(const string& value)
{
    vector<string> tokValue;
    split(tokValue, toLower(value), is_any_of(TOKENIZERS));

    Value *pos = &m_root;

    for(string tok : tokValue)
    {
        if(tok.size() < 1)
            continue;

        if(!pos->isInNext(tok))
            return 0.0;
        else
            pos = pos->goNext(tok);
    }

    if(!pos->isInNext(stringNULL))
        return 0.0;
    else
        return pos->goNext(stringNULL)->getOcc();
}


/////////////////////////////////////////
///
/// printing method's definitions
///
////////////////////////////////////////


ostream& operator<<(ostream& out, const Class& vs)
{
    out << "Class " << vs.m_name << " (" << vs.m_size << " studied)";
    for(SubSet* set : vs.m_sets)
        out << endl << *set;

    return out;
}

ostream& operator<<(ostream& out, const SubSet& s)
{
    out << "  SubSet " << s.setNames[s.m_id] << endl ;
    out << s.m_root;

    return out;
}

ostream& operator<<(ostream& out, const Value& v)
{
    v.print(out, "    ");
    return out;
}

void Value::print(ostream& out, const string prefix) const
{
    for(Value* next : m_next)
        if(m_value == "~")
            next->print(out, prefix);
        else
            next->print(out, prefix + m_value + "(" + to_string(m_occ)+") ");

    if(m_value == stringNULL)
        out << prefix << endl;
}